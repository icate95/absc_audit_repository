# absc_audit/checks/malware.py

"""
Malware Check - Implementazione dei controlli di protezione malware ABSC 8.x.

Questo modulo implementa i controlli relativi alla protezione da malware
secondo le specifiche ABSC 8.x.
"""

import time
import re
import os
from typing import Dict, List, Optional, Any, Tuple

from absc_audit.checks.base import BaseCheck
from absc_audit.storage.models import Target
from absc_audit.utils.logging import setup_logger

logger = setup_logger(__name__)


class AntimalwareCheck(BaseCheck):
    """
    Controllo per verificare la presenza di software anti-malware (ABSC 8.1.1-8.1.3).

    Verifica se sono installati strumenti anti-malware su tutti i sistemi con aggiornamento automatico.
    """

    ID = "8.1.1-8.1.3"
    NAME = "Protezione anti-malware"
    DESCRIPTION = "Protezione anti-malware su tutti i sistemi"
    QUESTION = "Sono installati strumenti anti-malware su tutti i sistemi con aggiornamento automatico?"
    POSSIBLE_ANSWERS = ["Sì con gestione centrale", "Sì", "No"]
    CATEGORY = "Malware"
    PRIORITY = 1  # Alta priorità

    # Tool comuni anti-malware
    ANTIMALWARE_TOOLS = [
        # Linux
        {"name": "ClamAV", "process": "clamd", "service": "clamav-daemon"},
        {"name": "Sophos", "process": "sophos", "service": "sophos-av"},
        {"name": "ESET", "process": "esets", "service": "esets"},
        {"name": "McAfee", "process": "mcafee", "service": "mcafee"},
        {"name": "F-Prot", "process": "f-prot", "service": "f-prot"},
        # Windows
        {"name": "Windows Defender", "process": "MsMpEng.exe", "service": "WinDefend"},
        {"name": "Symantec", "process": "rtvscan.exe", "service": "Symantec AntiVirus"},
        {"name": "McAfee", "process": "mcshield.exe", "service": "McAfeeFramework"},
        {"name": "Kaspersky", "process": "avp.exe", "service": "Kaspersky"},
        {"name": "ESET", "process": "ekrn.exe", "service": "ESET Service"},
        {"name": "Bitdefender", "process": "bdagent.exe", "service": "BDSS"},
        {"name": "Trend Micro", "process": "PccNTMon.exe", "service": "Trend Micro"},
    ]

    def run(self, target: Target, params: Dict = None) -> Dict:
        """
        Esegue il controllo sulla protezione anti-malware.

        Args:
            target: Target su cui eseguire il controllo
            params: Parametri aggiuntivi per il controllo (opzionale)

        Returns:
            Dizionario con i risultati del controllo
        """
        params = params or {}
        start_time = time.time()
        result = self.prepare_result()

        try:
            self.log_check_start(target)

            # 1. Verifica la presenza di tool anti-malware
            antimalware_tools = self._check_antimalware_tools(target)

            # 2. Verifica l'aggiornamento automatico delle firme
            auto_update = self._check_auto_update(target, antimalware_tools)

            # 3. Verifica la presenza di gestione centralizzata
            central_management = self._check_central_management(target, antimalware_tools)

            # Compila i risultati
            result['raw_data'] = {
                'antimalware_tools': antimalware_tools,
                'auto_update': auto_update,
                'central_management': central_management
            }

            # Determina lo stato
            if antimalware_tools and auto_update and central_management:
                result['status'] = "Sì con gestione centrale"
            elif antimalware_tools and auto_update:
                result['status'] = "Sì"
            else:
                result['status'] = "No"

            # Calcola punteggio
            result['score'] = self._calculate_custom_score(result['status'])

            # Aggiungi dettagli
            result['details'] = {
                'has_antimalware': bool(antimalware_tools),
                'has_auto_update': auto_update,
                'has_central_management': central_management,
                'antimalware_tools': [t['name'] for t in antimalware_tools]
            }

            # Aggiungi note
            if result['status'] == "No":
                result[
                    'notes'] = "Non sono stati trovati strumenti anti-malware attivi. È necessario installare un software anti-malware con aggiornamento automatico delle firme."
            elif result['status'] == "Sì":
                result[
                    'notes'] = "Software anti-malware installato con aggiornamento automatico. Si consiglia di implementare una gestione centralizzata."
            else:
                result['notes'] = "La protezione anti-malware è completamente implementata con gestione centralizzata."

        except Exception as e:
            self.log_error(target, e)
            result['status'] = "ERROR"
            result['details'] = {'error': str(e)}
            result['score'] = 0
        finally:
            duration = time.time() - start_time
            self.log_check_end(target, result['status'], duration)

        return result

    def _check_antimalware_tools(self, target: Target) -> List[Dict]:
        """
        Verifica la presenza di strumenti anti-malware.

        Args:
            target: Target su cui verificare

        Returns:
            Lista di dizionari con informazioni sugli strumenti trovati
        """
        self.logger.debug(f"Checking anti-malware tools on {target.name}")
        found_tools = []

        for tool in self.ANTIMALWARE_TOOLS:
            # Controlla se il processo è in esecuzione
            process_running = self.check_process_running(target, tool['process'])

            # Controlla lo stato del servizio
            service_status = {"running": False, "enabled": False}
            if tool['service']:
                service_status = self.check_service_status(target, tool['service'])

            if process_running or service_status.get('running', False):
                self.logger.info(f"Found anti-malware tool on {target.name}: {tool['name']}")
                found_tools.append({
                    'name': tool['name'],
                    'process_running': process_running,
                    'service_running': service_status.get('running', False),
                    'service_enabled': service_status.get('enabled', False)
                })

        # Controlla anche Windows Defender tramite PowerShell per Windows
        if target.os_type.lower() == 'windows':
            ps_cmd = 'powershell -Command "Get-MpComputerStatus | Format-List"'
            result = self.execute_command(target, ps_cmd)

            if result['exit_code'] == 0 and "AntivirusEnabled : True" in result['stdout']:
                # Evita duplicati se già trovato dal controllo del processo
                if not any(tool['name'] == "Windows Defender" for tool in found_tools):
                    self.logger.info(f"Found Windows Defender enabled on {target.name}")
                    found_tools.append({
                        'name': "Windows Defender",
                        'process_running': True,
                        'service_running': True,
                        'service_enabled': True
                    })

        return found_tools

    def _check_auto_update(self, target: Target, antimalware_tools: List[Dict]) -> bool:
        """
        Verifica l'aggiornamento automatico delle firme anti-malware.

        Args:
            target: Target su cui verificare
            antimalware_tools: Lista di strumenti anti-malware trovati

        Returns:
            True se l'aggiornamento automatico è configurato, False altrimenti
        """
        self.logger.debug(f"Checking anti-malware auto update on {target.name}")

        # Nessuno strumento anti-malware trovato
        if not antimalware_tools:
            return False

        # Controlla configurazioni specifiche per ogni strumento
        for tool in antimalware_tools:
            tool_name = tool['name']

            if tool_name == "ClamAV":
                # Controlla la configurazione di freshclam
                config_paths = ["/etc/clamav/freshclam.conf", "/etc/freshclam.conf"]
                for path in config_paths:
                    content = self.read_file_content(target, path)
                    if content and "Checks" in content and not re.search(r'#\s*Checks', content):
                        self.logger.info(f"Found ClamAV auto-update configuration on {target.name}")
                        return True

            elif tool_name == "Windows Defender":
                # Controlla le impostazioni di Windows Defender tramite PowerShell
                ps_cmd = 'powershell -Command "Get-MpComputerStatus | Select-Object -Property SignatureUpdateInterval, SignatureAge, AntivirusSignatureLastUpdated"'
                result = self.execute_command(target, ps_cmd)

                if result['exit_code'] == 0 and "SignatureUpdateInterval" in result['stdout']:
                    # Se l'intervallo di aggiornamento è configurato, l'aggiornamento è automatico
                    if not re.search(r'SignatureUpdateInterval\s+:\s+0', result['stdout']):
                        self.logger.info(f"Found Windows Defender auto-update configuration on {target.name}")
                        return True

            elif tool_name in ["Symantec", "McAfee", "Kaspersky", "ESET", "Bitdefender", "Trend Micro", "Sophos"]:
                # Strumenti di terze parti su Windows
                if target.os_type.lower() == 'windows':
                    # Controlla se c'è un'attività pianificata per l'aggiornamento
                    schtasks_cmd = f'schtasks /query /fo LIST /v | findstr /i "{tool_name}.*update"'
                    result = self.execute_command(target, schtasks_cmd)

                    if result['exit_code'] == 0 and result['stdout']:
                        self.logger.info(f"Found {tool_name} auto-update scheduled task on {target.name}")
                        return True

                # Strumenti di terze parti su Linux
                elif target.os_type.lower() in ['linux', 'unix']:
                    # Controlla i job cron
                    cron_cmd = f'grep -r "{tool_name.lower()}" /etc/cron*'
                    result = self.execute_command(target, cron_cmd)

                    if result['exit_code'] == 0 and result['stdout']:
                        self.logger.info(f"Found {tool_name} auto-update cron job on {target.name}")
                        return True

        # Controlla anche i servizi generici di aggiornamento anti-malware
        update_services = [
            # Linux
            "clamav-freshclam",
            "eset-update",
            "sophos-update",
            # Windows
            "McAfeeUpdaterService",
            "Symantec LiveUpdate",
            "ESETService"
        ]

        for service in update_services:
            status = self.check_service_status(target, service)
            if status.get('running', False):
                self.logger.info(f"Found anti-malware update service on {target.name}: {service}")
                return True

        # Ultima risorsa: controlla l'età delle firme
        # Per Windows Defender
        if target.os_type.lower() == 'windows' and any(t['name'] == "Windows Defender" for t in antimalware_tools):
            ps_cmd = 'powershell -Command "Get-MpComputerStatus | Select-Object -Property SignatureAge"'
            result = self.execute_command(target, ps_cmd)

            if result['exit_code'] == 0 and "SignatureAge" in result['stdout']:
                # Estrai l'età delle firme
                age_match = re.search(r'SignatureAge\s+:\s+(\d+)', result['stdout'])
                if age_match:
                    age = int(age_match.group(1))
                    # Se le firme sono state aggiornate negli ultimi 7 giorni, considera automatico
                    if age <= 7:
                        self.logger.info(
                            f"Windows Defender signatures recently updated on {target.name} (age: {age} days)")
                        return True

        return False

    def _check_central_management(self, target: Target, antimalware_tools: List[Dict]) -> bool:
        """
        Verifica la presenza di gestione centralizzata degli strumenti anti-malware.

        Args:
            target: Target su cui verificare
            antimalware_tools: Lista di strumenti anti-malware trovati

        Returns:
            True se è implementata la gestione centralizzata, False altrimenti
        """
        self.logger.debug(f"Checking anti-malware central management on {target.name}")

        # Nessuno strumento anti-malware trovato
        if not antimalware_tools:
            return False

        # Controlla configurazioni specifiche per ogni strumento
        for tool in antimalware_tools:
            tool_name = tool['name']

            if tool_name == "Windows Defender":
                # Controlla se è gestito da SCCM o Intune
                reg_cmd = 'reg query "HKLM\\SOFTWARE\\Microsoft\\CCM" /v SMSSiteCode'
                result = self.execute_command(target, reg_cmd)

                if result['exit_code'] == 0 and "REG_SZ" in result['stdout']:
                    self.logger.info(f"Found Windows Defender managed by SCCM on {target.name}")
                    return True

                # Verifica gestione Intune
                reg_cmd = 'reg query "HKLM\\SOFTWARE\\Microsoft\\IntuneManagementExtension"'
                result = self.execute_command(target, reg_cmd)

                if result['exit_code'] == 0 and result['stdout']:
                    self.logger.info(f"Found Windows Defender managed by Intune on {target.name}")
                    return True

            elif tool_name in ["Symantec", "McAfee", "Kaspersky", "ESET", "Bitdefender", "Trend Micro", "Sophos"]:
                # Controlla file di configurazione che indicano gestione centralizzata

                # Windows
                if target.os_type.lower() == 'windows':
                    config_paths = [
                        f"C:\\Program Files\\{tool_name}\\central.conf",
                        f"C:\\Program Files\\{tool_name}\\managed.conf",
                        f"C:\\Program Files\\{tool_name}\\server.conf",
                        f"C:\\Program Files (x86)\\{tool_name}\\central.conf",
                        f"C:\\Program Files (x86)\\{tool_name}\\managed.conf",
                        f"C:\\Program Files (x86)\\{tool_name}\\server.conf"
                    ]

                    for path in config_paths:
                        if self.check_file_exists(target, path):
                            self.logger.info(
                                f"Found {tool_name} central management configuration on {target.name}: {path}")
                            return True

                    # Controlla anche i registri
                    reg_cmd = f'reg query "HKLM\\SOFTWARE\\{tool_name}" /s | findstr /i "server\\|central\\|managed"'
                    result = self.execute_command(target, reg_cmd)

                    if result['exit_code'] == 0 and result['stdout']:
                        self.logger.info(f"Found {tool_name} central management registry entries on {target.name}")
                        return True

                # Linux
                elif target.os_type.lower() in ['linux', 'unix']:
                    config_paths = [
                        f"/etc/{tool_name.lower()}/central.conf",
                        f"/etc/{tool_name.lower()}/managed.conf",
                        f"/etc/{tool_name.lower()}/server.conf",
                        f"/opt/{tool_name.lower()}/etc/central.conf",
                        f"/opt/{tool_name.lower()}/etc/managed.conf",
                        f"/opt/{tool_name.lower()}/etc/server.conf"
                    ]

                    for path in config_paths:
                        if self.check_file_exists(target, path):
                            self.logger.info(
                                f"Found {tool_name} central management configuration on {target.name}: {path}")
                            return True

        # Controlla per agenti di gestione generici
        management_agents = [
            # Windows
            {"name": "SCCM Client", "process": "CcmExec.exe", "service": "CCMExec"},
            {"name": "Tanium Client", "process": "TaniumClient.exe", "service": "Tanium Client"},
            {"name": "BigFix Client", "process": "BESClient.exe", "service": "BESClient"},
            {"name": "Ivanti Endpoint Manager", "process": "LDClient.exe", "service": "LDClient"},
            # Linux
            {"name": "SCCM Client", "process": "ccmexec", "service": "ccmexec"},
            {"name": "Tanium Client", "process": "TaniumClient", "service": "taniumclient"},
            {"name": "BigFix Client", "process": "BESClient", "service": "besclient"},
            {"name": "Puppet Agent", "process": "puppet", "service": "puppet"},
            {"name": "Chef Client", "process": "chef-client", "service": "chef-client"},
            {"name": "Ansible Agent", "process": "ansible", "service": None}
        ]

        for agent in management_agents:
            # Controlla se il processo è in esecuzione
            process_running = self.check_process_running(target, agent['process'])

            # Controlla lo stato del servizio
            service_status = {"running": False}
            if agent['service']:
                service_status = self.check_service_status(target, agent['service'])

            if process_running or service_status.get('running', False):
                self.logger.info(f"Found management agent on {target.name}: {agent['name']}")
                return True

        return False

    def _calculate_custom_score(self, status: str) -> float:
        """
        Calcola un punteggio personalizzato in base allo stato.

        Args:
            status: Stato del controllo

        Returns:
            Punteggio da 0 a 100
        """
        if status == "Sì con gestione centrale":
            return 100
        elif status == "Sì":
            return 70
        elif status == "No":
            return 0
        else:
            return 0


class ExecutionPreventionCheck(BaseCheck):
    """
    Controllo per verificare l'implementazione di misure di prevenzione dell'esecuzione di codice non autorizzato (ABSC 8.2.1-8.2.3).

    Verifica se sono implementate le misure di prevenzione dell'esecuzione di software non autorizzato.
    """

    ID = "8.2.1-8.2.3"
    NAME = "Prevenzione dell'esecuzione"
    DESCRIPTION = "Misure di prevenzione dell'esecuzione di codice non autorizzato"
    QUESTION = "Sono implementate le misure di prevenzione dell'esecuzione di software non autorizzato?"
    POSSIBLE_ANSWERS = ["Sì con blocco esecuzione", "Sì senza blocco", "Sì con whitelist mirata", "No"]
    CATEGORY = "Malware"
    PRIORITY = 1  # Alta priorità

    def run(self, target: Target, params: Dict = None) -> Dict:
        """
        Esegue il controllo sulle misure di prevenzione dell'esecuzione di codice non autorizzato.

        Args:
            target: Target su cui eseguire il controllo
            params: Parametri aggiuntivi per il controllo (opzionale)

        Returns:
            Dizionario con i risultati del controllo
        """
        params = params or {}
        start_time = time.time()
        result = self.prepare_result()

        try:
            self.log_check_start(target)

            # 1. Verifica l'implementazione di Application Control
            app_control = self._check_application_control(target)

            # 2. Verifica l'implementazione di blocco esecuzione
            execution_blocking = self._check_execution_blocking(target)

            # 3. Verifica l'implementazione di whitelist
            whitelist = self._check_whitelist(target)

            # Compila i risultati
            result['raw_data'] = {
                'app_control': app_control,
                'execution_blocking': execution_blocking,
                'whitelist': whitelist
            }

            # Determina lo stato
            if app_control and execution_blocking:
                result['status'] = "Sì con blocco esecuzione"
            elif app_control and not execution_blocking:
                result['status'] = "Sì senza blocco"
            elif whitelist:
                result['status'] = "Sì con whitelist mirata"
            else:
                result['status'] = "No"

            # Calcola punteggio
            result['score'] = self._calculate_custom_score(result['status'])

            # Aggiungi dettagli
            result['details'] = {
                'has_app_control': app_control,
                'has_execution_blocking': execution_blocking,
                'has_whitelist': whitelist,
                'app_control_details': app_control,
                'execution_blocking_details': execution_blocking,
                'whitelist_details': whitelist
            }

            # Aggiungi note
            if result['status'] == "No":
                result[
                    'notes'] = "Non sono state trovate misure di prevenzione dell'esecuzione di codice non autorizzato. È necessario implementare soluzioni di Application Control."
            elif result['status'] == "Sì con whitelist mirata":
                result[
                    'notes'] = "È implementata una whitelist mirata. Si consiglia di estendere l'Application Control a tutto il sistema."
            elif result['status'] == "Sì senza blocco":
                result[
                    'notes'] = "L'Application Control è implementato ma senza blocco dell'esecuzione. Si consiglia di abilitare il blocco."
            else:
                result['notes'] = "L'Application Control è completamente implementato con blocco dell'esecuzione."

        except Exception as e:
            self.log_error(target, e)
            result['status'] = "ERROR"
            result['details'] = {'error': str(e)}
            result['score'] = 0
        finally:
            duration = time.time() - start_time
            self.log_check_end(target, result['status'], duration)

        return result

    def _check_application_control(self, target: Target) -> Dict:
        """
        Verifica l'implementazione di Application Control.

        Args:
            target: Target su cui verificare

        Returns:
            Dizionario con informazioni sull'Application Control
        """
        self.logger.debug(f"Checking Application Control on {target.name}")

        app_control = {
            'implemented': False,
            'software': None,
            'config_path': None,
            'policy_details': None
        }

        if target.os_type.lower() == 'windows':
            # Controlla AppLocker
            ps_cmd = 'powershell -Command "Get-AppLockerPolicy -Effective | Format-List"'
            result = self.execute_command(target, ps_cmd)

            if result['exit_code'] == 0 and result['stdout'] and "RuleCollections" in result['stdout']:
                app_control['implemented'] = True
                app_control['software'] = "AppLocker"
                app_control['config_path'] = "Group Policy"
                app_control['policy_details'] = "AppLocker policy active"
                return app_control

            # Controlla Software Restriction Policies
            reg_cmd = 'reg query "HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\Safer"'
            result = self.execute_command(target, reg_cmd)

            if result['exit_code'] == 0 and result['stdout']:
                app_control['implemented'] = True
                app_control['software'] = "Software Restriction Policies"
                app_control['config_path'] = "Registry"
                app_control['policy_details'] = "SRP active"
                return app_control

            # Controlla Windows Defender Application Control
            ps_cmd = 'powershell -Command "Get-CimInstance -ClassName Win32_DeviceGuard -Namespace root\\Microsoft\\Windows\\DeviceGuard | Select-Object SecurityServicesRunning, VirtualizationBasedSecurityStatus"'
            result = self.execute_command(target, ps_cmd)

            if result['exit_code'] == 0 and result['stdout'] and "SecurityServicesRunning" in result['stdout']:
                if "1" in result['stdout'] or "3" in result['stdout']:  # 1 o 3 include Application Control
                    app_control['implemented'] = True
                    app_control['software'] = "Windows Defender Application Control"
                    app_control['config_path'] = "Group Policy"
                    app_control['policy_details'] = "WDAC active"
                    return app_control

        elif target.os_type.lower() in ['linux', 'unix']:
            # Controlla SELinux
            selinux_cmd = 'getenforce 2>/dev/null || sestatus 2>/dev/null || cat /etc/selinux/config 2>/dev/null'
            result = self.execute_command(target, selinux_cmd)

            if result['exit_code'] == 0 and result['stdout']:
                if "Enforcing" in result['stdout'] or "SELINUX=enforcing" in result['stdout']:
                    app_control['implemented'] = True
                    app_control['software'] = "SELinux"
                    app_control['config_path'] = "/etc/selinux/config"
                    app_control['policy_details'] = "SELinux enforcing"
                    return app_control

            # Controlla AppArmor
            apparmor_cmd = 'aa-status 2>/dev/null || cat /etc/apparmor/parser.conf 2>/dev/null || cat /sys/module/apparmor/parameters/enabled 2>/dev/null'
            result = self.execute_command(target, apparmor_cmd)

            if result['exit_code'] == 0 and result['stdout']:
                if "profiles are loaded" in result['stdout'] or "Y" in result['stdout']:
                    app_control['implemented'] = True
                    app_control['software'] = "AppArmor"
                    app_control['config_path'] = "/etc/apparmor"
                    app_control['policy_details'] = "AppArmor enabled"
                    return app_control

        # Controlla soluzioni di terze parti
        third_party_solutions = [
            # Windows
            {"name": "Symantec Application Control", "process": "SepMasterService.exe", "service": "SepMasterService"},
            {"name": "McAfee Application Control", "process": "macmnsvc.exe", "service": "macmnsvc"},
            {"name": "CyberArk EPM", "process": "EPMService.exe", "service": "EPMService"},
            {"name": "Carbon Black", "process": "CbDefense.exe", "service": "CbDefense"},
            # Linux
            {"name": "Symantec Application Control", "process": "sepmasterservice", "service": "sepmasterservice"},
            {"name": "McAfee Application Control", "process": "macmnsvc", "service": "macmnsvc"},
            {"name": "Carbon Black", "process": "cbdefense", "service": "cbdefense"},
        ]

        for solution in third_party_solutions:
            # Controlla se il processo è in esecuzione
            process_running = self.check_process_running(target, solution['process'])

            # Controlla lo stato del servizio
            service_status = {"running": False}
            if solution['service']:
                service_status = self.check_service_status(target, solution['service'])

            if process_running or service_status.get('running', False):
                app_control['implemented'] = True
                app_control['software'] = solution['name']
                app_control['config_path'] = "Unknown"
                app_control['policy_details'] = f"{solution['name']} active"
                return app_control

        return app_control

    def _check_execution_blocking(self, target: Target) -> bool:
        """
        Verifica l'implementazione del blocco dell'esecuzione.

        Args:
            target: Target su cui verificare

        Returns:
            True se il blocco dell'esecuzione è implementato, False altrimenti
        """
        self.logger.debug(f"Checking execution blocking on {target.name}")

        if target.os_type.lower() == 'windows':
            # Controlla AppLocker in modalità blocco
            ps_cmd = 'powershell -Command "Get-AppLockerPolicy -Effective | Where-Object {$_.RuleCollections.EnforcementMode -eq \'Enforce\'} | Format-List"'
            result = self.execute_command(target, ps_cmd)

            if result['exit_code'] == 0 and result['stdout'] and "RuleCollections" in result['stdout']:
                return True

            # Controlla Windows Defender Application Control in modalità blocco
            ps_cmd = 'powershell -Command "Get-CimInstance -ClassName Win32_DeviceGuard -Namespace root\\Microsoft\\Windows\\DeviceGuard | Where-Object {$_.SecurityServicesConfigured -band 1}"'
            result = self.execute_command(target, ps_cmd)

            if result['exit_code'] == 0 and result['stdout'] and len(result['stdout']) > 0:
                return True

            # Controlla Software Restriction Policies in modalità blocco
            reg_cmd = 'reg query "HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\Safer\\CodeIdentifiers" /v "DefaultLevel"'
            result = self.execute_command(target, reg_cmd)

            if result['exit_code'] == 0 and "0x00040000" in result['stdout']:  # Disallowed
                return True

        elif target.os_type.lower() in ['linux', 'unix']:
            # Controlla SELinux in modalità enforcing
            selinux_cmd = 'getenforce 2>/dev/null'
            result = self.execute_command(target, selinux_cmd)

            if result['exit_code'] == 0 and "Enforcing" in result['stdout']:
                return True

            # Controlla AppArmor in modalità enforce
            apparmor_cmd = 'aa-status 2>/dev/null | grep -c "enforce mode"'
            result = self.execute_command(target, apparmor_cmd)

            if result['exit_code'] == 0 and result['stdout'] and int(result['stdout'].strip()) > 0:
                return True

        # Controlla soluzioni di terze parti
        # Questo richiederebbe implementazioni specifiche per ogni soluzione

        return False

    def _check_whitelist(self, target: Target) -> Dict:
        """
        Verifica l'implementazione di whitelist.

        Args:
            target: Target su cui verificare

        Returns:
            Dizionario con informazioni sulla whitelist
        """
        self.logger.debug(f"Checking whitelist on {target.name}")

        whitelist = {
            'implemented': False,
            'type': None,
            'path': None,
            'details': None
        }

        if target.os_type.lower() == 'windows':
            # Controlla AppLocker con regole di whitelist
            ps_cmd = 'powershell -Command "Get-AppLockerPolicy -Effective | Where-Object {$_.RuleCollections.Count -gt 0} | Format-List"'
            result = self.execute_command(target, ps_cmd)

            if result['exit_code'] == 0 and result['stdout'] and "RuleCollections" in result['stdout']:
                whitelist['implemented'] = True
                whitelist['type'] = "AppLocker Whitelist"
                whitelist['path'] = "Group Policy"
                whitelist['details'] = "AppLocker whitelist rules active"
                return whitelist

            # Controlla Software Restriction Policies con whitelist
            reg_cmd = 'reg query "HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\Safer\\CodeIdentifiers\\0\\Paths" /s'
            result = self.execute_command(target, reg_cmd)

            if result['exit_code'] == 0 and result['stdout']:
                whitelist['implemented'] = True
                whitelist['type'] = "SRP Whitelist"
                whitelist['path'] = "Registry"
                whitelist['details'] = "SRP path rules active"
                return whitelist

        elif target.os_type.lower() in ['linux', 'unix']:
            # Controlla se esistono regole personalizzate in SELinux
            selinux_cmd = 'ls -la /etc/selinux/*/modules/active/modules/ 2>/dev/null | wc -l'
            result = self.execute_command(target, selinux_cmd)

            if result['exit_code'] == 0 and result['stdout'] and int(result['stdout'].strip()) > 0:
                whitelist['implemented'] = True
                whitelist['type'] = "SELinux Custom Modules"
                whitelist['path'] = "/etc/selinux"
                whitelist['details'] = "SELinux custom modules active"
                return whitelist

            # Controlla se esistono profili personalizzati in AppArmor
            # Controlla se esistono profili personalizzati in AppArmor
            apparmor_cmd = 'ls -la /etc/apparmor.d/ 2>/dev/null | grep -v "^d" | grep -v -e "abstractions" -e "tunables" -e "disable" | wc -l'
            result = self.execute_command(target, apparmor_cmd)

            if result['exit_code'] == 0 and result['stdout'] and int(result['stdout'].strip()) > 0:
                whitelist['implemented'] = True
                whitelist['type'] = "AppArmor Custom Profiles"
                whitelist['path'] = "/etc/apparmor.d"
                whitelist['details'] = "AppArmor custom profiles active"
                return whitelist

        # Cerca file di whitelist comuni
        whitelist_paths = [
            # Windows
            "C:\\ProgramData\\Application Whitelist\\whitelist.xml",
            "C:\\ProgramData\\Security\\allowed_executables.txt",
            # Linux
            "/etc/security/whitelist.conf",
            "/opt/security/allowed_executables.txt"
        ]

        for path in whitelist_paths:
            if self.check_file_exists(target, path):
                whitelist['implemented'] = True
                whitelist['type'] = "Custom Whitelist"
                whitelist['path'] = path
                whitelist['details'] = "Custom whitelist file found"
                return whitelist

        return whitelist

    def _calculate_custom_score(self, status: str) -> float:
        """
        Calcola un punteggio personalizzato in base allo stato.

        Args:
            status: Stato del controllo

        Returns:
            Punteggio da 0 a 100
        """
        if status == "Sì con blocco esecuzione":
            return 100
        elif status == "Sì senza blocco":
            return 70
        elif status == "Sì con whitelist mirata":
            return 50
        elif status == "No":
            return 0
        else:
            return 0