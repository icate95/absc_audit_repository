# absc_audit/checks/vulnerability.py

"""
Vulnerability Check - Implementazione dei controlli di vulnerabilità ABSC 4.x.

Questo modulo implementa i controlli relativi alla gestione delle vulnerabilità
secondo le specifiche ABSC 4.x.
"""

import time
import re
import os
import json
from typing import Dict, List, Optional, Any, Tuple

from absc_audit.checks.base import BaseCheck
from absc_audit.storage.models import Target
from absc_audit.utils.logging import setup_logger

logger = setup_logger(__name__)


class VulnerabilityScanCheck(BaseCheck):
    """
    Controllo per verificare l'esecuzione di scansioni di vulnerabilità (ABSC 4.1.1-4.1.3).

    Verifica se viene eseguita una ricerca delle vulnerabilità a seguito di modifiche significative e periodicamente.
    """

    ID = "4.1.1-4.1.3"
    NAME = "Ricerca periodica delle vulnerabilità"
    DESCRIPTION = "Ricerca periodica delle vulnerabilità"
    QUESTION = "Viene eseguita una ricerca delle vulnerabilità a seguito di modifiche significative e periodicamente?"
    POSSIBLE_ANSWERS = ["Sì automatizzata e periodica", "Sì solo a seguito di modifiche", "No"]
    CATEGORY = "Vulnerability"
    PRIORITY = 1  # Alta priorità

    # Tool comuni per la scansione di vulnerabilità
    VULNERABILITY_TOOLS = [
        # Linux
        {"name": "OpenVAS", "process": "openvassd", "service": "openvassd"},
        {"name": "Nessus", "process": "nessusd", "service": "nessusd"},
        {"name": "OVAL", "process": "oval", "service": "oval"},
        {"name": "Lynis", "process": "lynis", "service": None},
        {"name": "Nikto", "process": "nikto", "service": None},
        # Windows
        {"name": "Nessus", "process": "Nessus.exe", "service": "Tenable Nessus"},
        {"name": "OpenVAS", "process": "openvassd.exe", "service": "OpenVAS"},
        {"name": "Qualys", "process": "qualys-cloud-agent.exe", "service": "QualysAgent"},
    ]

    # Percorsi comuni per i log di scansione vulnerabilità
    SCAN_LOG_PATHS = [
        # Linux
        "/var/log/openvas/",
        "/var/log/nessus/",
        "/var/log/vulnerability-scan/",
        "/var/log/oval/",
        "/var/log/lynis/",
        # Windows
        "C:\\ProgramData\\Tenable\\Nessus\\logs\\",
        "C:\\ProgramData\\OpenVAS\\logs\\",
        "C:\\ProgramData\\Qualys\\logs\\",
    ]

    def run(self, target: Target, params: Dict = None) -> Dict:
        """
        Esegue il controllo sull'esecuzione di scansioni di vulnerabilità.

        Args:
            target: Target su cui eseguire il controllo
            params: Parametri aggiuntivi per il controllo (opzionale)

        Returns:
            Dizionario con i risultati del controllo
        """
        params = params or {}
        start_time = time.time()
        result = self.prepare_result()

        try:
            self.log_check_start(target)

            # 1. Verifica la presenza di tool di scansione vulnerabilità
            vulnerability_tools = self._check_vulnerability_tools(target)

            # 2. Verifica l'esecuzione periodica di scansioni
            periodic_scans = self._check_periodic_scans(target)

            # 3. Verifica l'esecuzione di scansioni dopo modifiche
            post_change_scans = self._check_post_change_scans(target)

            # 4. Verifica la presenza di report di scansione recenti
            recent_scan_reports = self._check_recent_scan_reports(target)

            # Compila i risultati
            result['raw_data'] = {
                'vulnerability_tools': vulnerability_tools,
                'periodic_scans': periodic_scans,
                'post_change_scans': post_change_scans,
                'recent_scan_reports': recent_scan_reports
            }

            # Determina lo stato
            if vulnerability_tools and periodic_scans and recent_scan_reports:
                result['status'] = "Sì automatizzata e periodica"
            elif vulnerability_tools and post_change_scans:
                result['status'] = "Sì solo a seguito di modifiche"
            else:
                result['status'] = "No"

            # Calcola punteggio
            result['score'] = self._calculate_custom_score(result['status'])

            # Aggiungi dettagli
            result['details'] = {
                'has_vulnerability_tools': bool(vulnerability_tools),
                'has_periodic_scans': periodic_scans,
                'has_post_change_scans': post_change_scans,
                'has_recent_scan_reports': bool(recent_scan_reports),
                'vulnerability_tools': [t['name'] for t in vulnerability_tools],
                'recent_reports': [r['path'] for r in recent_scan_reports]
            }

            # Aggiungi note
            if result['status'] == "No":
                result[
                    'notes'] = "Non è stata trovata alcuna evidenza di scansioni di vulnerabilità. È necessario implementare un processo di ricerca periodica delle vulnerabilità."
            elif result['status'] == "Sì solo a seguito di modifiche":
                result[
                    'notes'] = "Le scansioni di vulnerabilità vengono eseguite solo a seguito di modifiche. Si consiglia di implementare anche scansioni periodiche automatizzate."
            else:
                result['notes'] = "Scansioni di vulnerabilità automatizzate e periodiche correttamente implementate."

        except Exception as e:
            self.log_error(target, e)
            result['status'] = "ERROR"
            result['details'] = {'error': str(e)}
            result['score'] = 0
        finally:
            duration = time.time() - start_time
            self.log_check_end(target, result['status'], duration)

        return result

    def _check_vulnerability_tools(self, target: Target) -> List[Dict]:
        """
        Verifica la presenza di tool per la scansione di vulnerabilità.

        Args:
            target: Target su cui verificare

        Returns:
            Lista di dizionari con informazioni sui tool trovati
        """
        self.logger.debug(f"Checking vulnerability scanning tools on {target.name}")
        found_tools = []

        for tool in self.VULNERABILITY_TOOLS:
            # Controlla se il processo è in esecuzione
            process_running = self.check_process_running(target, tool['process'])

            # Controlla lo stato del servizio
            service_status = {"running": False, "enabled": False}
            if tool['service']:
                service_status = self.check_service_status(target, tool['service'])

            if process_running or service_status.get('running', False):
                self.logger.info(f"Found vulnerability scanning tool on {target.name}: {tool['name']}")
                found_tools.append({
                    'name': tool['name'],
                    'process_running': process_running,
                    'service_running': service_status.get('running', False),
                    'service_enabled': service_status.get('enabled', False)
                })

        return found_tools

    def _check_periodic_scans(self, target: Target) -> bool:
        """
        Verifica se sono configurate scansioni periodiche.

        Args:
            target: Target su cui verificare

        Returns:
            True se sono configurate scansioni periodiche, False altrimenti
        """
        self.logger.debug(f"Checking periodic vulnerability scans on {target.name}")

        # Controlla i job cron/scheduled tasks per le scansioni periodiche
        if target.os_type.lower() in ['linux', 'unix']:
            # Cerca nei file crontab
            cron_paths = ['/etc/crontab', '/var/spool/cron/crontabs/root']
            for path in cron_paths:
                content = self.read_file_content(target, path)
                if content and re.search(r'vulnerability|openvas|nessus|scan|oval|lynis', content, re.IGNORECASE):
                    self.logger.info(f"Found periodic vulnerability scan cron job on {target.name}: {path}")
                    return True

        elif target.os_type.lower() == 'windows':
            # Esegui il comando schtasks
            result = self.execute_command(target,
                                          'schtasks /query /fo LIST /v | findstr /i "vulnerability openvas nessus scan"')
            if result['exit_code'] == 0 and result['stdout']:
                self.logger.info(f"Found periodic vulnerability scan scheduled task on {target.name}")
                return True

        # Controlla anche i tool di scansione che supportano la pianificazione
        for tool in self.VULNERABILITY_TOOLS:
            if tool['name'] in ["OpenVAS", "Nessus", "Qualys"] and (
                    self.check_process_running(target, tool['process']) or self.check_service_status(target, tool[
                'service']).get('running', False)):
                # Questi tool supportano la pianificazione per default
                # Controlliamo le configurazioni specifiche

                if tool['name'] == "OpenVAS":
                    config_paths = ["/etc/openvas/openvassd.conf", "C:\\Program Files\\OpenVAS\\openvassd.conf"]
                    for path in config_paths:
                        content = self.read_file_content(target, path)
                        if content and re.search(r'schedule|periodic|interval', content, re.IGNORECASE):
                            return True

                elif tool['name'] == "Nessus":
                    config_paths = ["/opt/nessus/etc/nessus/nessusd.conf",
                                    "C:\\ProgramData\\Tenable\\Nessus\\nessus\\nessusd.conf"]
                    for path in config_paths:
                        content = self.read_file_content(target, path)
                        if content and re.search(r'schedule|periodic|interval', content, re.IGNORECASE):
                            return True

                elif tool['name'] == "Qualys":
                    config_paths = ["/etc/qualys/qualys-cloud-agent.conf",
                                    "C:\\ProgramData\\Qualys\\QualysAgent\\Config\\qualys-cloud-agent.conf"]
                    for path in config_paths:
                        content = self.read_file_content(target, path)
                        if content and re.search(r'scan_interval|periodic|scan_schedule', content, re.IGNORECASE):
                            return True

        return False

    def _check_post_change_scans(self, target: Target) -> bool:
        """
        Verifica se sono configurate scansioni dopo modifiche significative.

        Args:
            target: Target su cui verificare

        Returns:
            True se sono configurate scansioni post-modifica, False altrimenti
        """
        self.logger.debug(f"Checking post-change vulnerability scans on {target.name}")

        # Controlla la presenza di procedure/script per scansioni post-modifica
        script_paths = [
            # Linux
            "/usr/local/bin/post-change-scan.sh",
            "/usr/local/bin/change-detection.py",
            "/etc/vulnerability/post-change.conf",
            # Windows
            "C:\\Scripts\\PostChangeScan.ps1",
            "C:\\Programs\\Vulnerability\\ChangeDetection.bat",
            "C:\\ProgramData\\Vulnerability\\post-change.conf"
        ]

        for path in script_paths:
            if self.check_file_exists(target, path):
                self.logger.info(f"Found post-change vulnerability scan script on {target.name}: {path}")
                return True

        # Controlla la presenza di hook CI/CD o di configurazione
        if target.os_type.lower() in ['linux', 'unix']:
            hook_paths = [
                "/etc/puppet/hooks/",
                "/etc/ansible/hooks/",
                "/var/lib/jenkins/hooks/",
                "/etc/chef/hooks/",
                "/etc/salt/hooks/"
            ]

            for path in hook_paths:
                if self.check_file_exists(target, path):
                    # Cerca file che contengono riferimenti a scansioni
                    cmd = f"find {path} -type f -exec grep -l 'vulnerability\\|scan\\|openvas\\|nessus' {{}} \\;"
                    result = self.execute_command(target, cmd)
                    if result['exit_code'] == 0 and result['stdout']:
                        self.logger.info(
                            f"Found post-change vulnerability scan hook on {target.name}: {result['stdout']}")
                        return True

        # Controlla la documentazione di procedure
        doc_paths = [
            # Linux
            "/etc/vulnerability/procedures.md",
            "/opt/security/docs/vulnerability-management.pdf",
            # Windows
            "C:\\Security\\Docs\\VulnerabilityManagement.docx",
            "C:\\ProgramData\\Security\\Procedures.pdf"
        ]

        for path in doc_paths:
            if self.check_file_exists(target, path):
                content = self.read_file_content(target, path)
                if content and re.search(r'post[- ]change|after change|following change|change management.*scan',
                                         content, re.IGNORECASE):
                    self.logger.info(f"Found post-change vulnerability scan documentation on {target.name}: {path}")
                    return True

        return False

    def _check_recent_scan_reports(self, target: Target) -> List[Dict]:
        """
        Verifica la presenza di report di scansione recenti.

        Args:
            target: Target su cui verificare

        Returns:
            Lista di dizionari con informazioni sui report trovati
        """
        self.logger.debug(f"Checking recent vulnerability scan reports on {target.name}")
        found_reports = []

        # Controlla nei percorsi comuni per i report di scansione
        report_paths = [
            # Linux
            "/var/lib/openvas/results/",
            "/var/lib/nessus/results/",
            "/var/log/vulnerability-scan/reports/",
            "/var/log/oval/reports/",
            "/var/log/lynis/reports/",
            # Windows
            "C:\\ProgramData\\Tenable\\Nessus\\results\\",
            "C:\\ProgramData\\OpenVAS\\results\\",
            "C:\\ProgramData\\Qualys\\reports\\"
        ]

        for base_path in report_paths:
            # Controlla se la directory esiste
            if not self.check_file_exists(target, base_path):
                continue

            # Elenca i file nella directory
            if target.os_type.lower() in ['linux', 'unix']:
                cmd = f"find {base_path} -type f -name '*.xml' -o -name '*.json' -o -name '*.pdf' -o -name '*.html' -mtime -30 | sort -r | head -5"
            else:  # Windows
                cmd = f'dir /b /s /a-d "{base_path}*.xml" "{base_path}*.json" "{base_path}*.pdf" "{base_path}*.html" | sort /R'

            result = self.execute_command(target, cmd)

            if result['exit_code'] == 0 and result['stdout']:
                # Analizza l'output per trovare i report
                for line in result['stdout'].splitlines():
                    path = line.strip()
                    if path:
                        # Ottieni la data di modifica
                        modified_time = time.time() - 90 * 24 * 60 * 60  # Default a 90 giorni fa
                        if target.os_type.lower() in ['linux', 'unix']:
                            stat_cmd = f"stat -c %Y '{path}'"
                            stat_result = self.execute_command(target, stat_cmd)
                            if stat_result['exit_code'] == 0 and stat_result['stdout']:
                                try:
                                    modified_time = int(stat_result['stdout'].strip())
                                except ValueError:
                                    pass
                        else:  # Windows
                            # Powershell per ottenere l'ultima modifica
                            ps_cmd = f'powershell -Command "(Get-Item -Path \'{path}\').LastWriteTime.ToString(\'yyyy-MM-dd\')"'
                            ps_result = self.execute_command(target, ps_cmd)
                            if ps_result['exit_code'] == 0 and ps_result['stdout']:
                                try:
                                    date_str = ps_result['stdout'].strip()
                                    # Conversione molto semplificata, in una implementazione reale usare datetime
                                    modified_time = time.time() - (
                                                30 * 24 * 60 * 60)  # Assume 30 giorni fa per semplicità
                                except Exception:
                                    pass

                        # Verifica se il report è recente (meno di 30 giorni)
                        is_recent = (time.time() - modified_time) < (30 * 24 * 60 * 60)

                        if is_recent:
                            found_reports.append({
                                'path': path,
                                'modified_time': modified_time,
                                'is_recent': is_recent
                            })

        return found_reports

    def _calculate_custom_score(self, status: str) -> float:
        """
        Calcola un punteggio personalizzato in base allo stato.

        Args:
            status: Stato del controllo

        Returns:
            Punteggio da 0 a 100
        """
        if status == "Sì automatizzata e periodica":
            return 100
        elif status == "Sì solo a seguito di modifiche":
            return 60
        elif status == "No":
            return 0
        else:
            return 0


class PatchManagementCheck(BaseCheck):
    """
    Controllo per verificare la gestione delle patch di sicurezza (ABSC 4.5.1-4.5.2).

    Verifica se sono installati strumenti automatici di aggiornamento dei sistemi operativi e del software.
    """

    ID = "4.5.1-4.5.2"
    NAME = "Gestione delle patch di sicurezza"
    DESCRIPTION = "Installazione e verifica di strumenti automatici per l'aggiornamento del software"
    QUESTION = "Sono installati strumenti automatici di aggiornamento dei sistemi operativi e del software?"
    POSSIBLE_ANSWERS = ["Sì con verifica attacchi pregressi", "Sì automatico con versioni e patch",
                        "Sì solo applicazioni", "No"]
    CATEGORY = "Vulnerability"
    PRIORITY = 1  # Alta priorità

    # Tool comuni per la gestione delle patch
    PATCH_TOOLS = [
        # Linux
        {"name": "Unattended Upgrades", "process": "unattended-upgrade", "service": "unattended-upgrades"},
        {"name": "Yum-Cron", "process": "yum-cron", "service": "yum-cron"},
        {"name": "Dnf-Automatic", "process": "dnf-automatic", "service": "dnf-automatic.timer"},
        {"name": "Zypper-Automatic", "process": "zypper-automatic", "service": "zypper-automatic.timer"},
        {"name": "Landscape", "process": "landscape-client", "service": "landscape-client"},
        {"name": "Spacewalk", "process": "spacewalk-client", "service": "rhsmcertd"},
        # Windows
        {"name": "Windows Update", "process": "wuauserv", "service": "wuauserv"},
        {"name": "WSUS", "process": "wsus", "service": "WsusService"},
        {"name": "SCCM", "process": "CcmExec", "service": "CcmExec"},
        {"name": "Patch Manager", "process": "PatchManager", "service": "PatchManagerService"},
    ]

    def run(self, target: Target, params: Dict = None) -> Dict:
        """
        Esegue il controllo sulla gestione delle patch di sicurezza.

        Args:
            target: Target su cui eseguire il controllo
            params: Parametri aggiuntivi per il controllo (opzionale)

        Returns:
            Dizionario con i risultati del controllo
        """
        params = params or {}
        start_time = time.time()
        result = self.prepare_result()

        try:
            self.log_check_start(target)

            # 1. Verifica la presenza di tool per la gestione delle patch
            patch_tools = self._check_patch_tools(target)

            # 2. Verifica la configurazione dell'aggiornamento automatico
            auto_update_config = self._check_auto_update_config(target)

            # 3. Verifica la presenza di aggiornamenti recenti
            recent_updates = self._check_recent_updates(target)

            # 4. Verifica la scansione per attacchi pregressi
            attack_scan = self._check_attack_scan(target)

            # Compila i risultati
            result['raw_data'] = {
                'patch_tools': patch_tools,
                'auto_update_config': auto_update_config,
                'recent_updates': recent_updates,
                'attack_scan': attack_scan
            }

            # Determina lo stato
            if patch_tools and auto_update_config and attack_scan:
                result['status'] = "Sì con verifica attacchi pregressi"
            elif patch_tools and auto_update_config:
                result['status'] = "Sì automatico con versioni e patch"
            elif patch_tools:
                result['status'] = "Sì solo applicazioni"
            else:
                result['status'] = "No"

            # Calcola punteggio
            result['score'] = self._calculate_custom_score(result['status'])

            # Aggiungi dettagli
            result['details'] = {
                'has_patch_tools': bool(patch_tools),
                'has_auto_update': auto_update_config,
                'has_recent_updates': bool(recent_updates),
                'has_attack_scan': attack_scan,
                'patch_tools': [t['name'] for t in patch_tools],
            }

            # Aggiungi note
            if result['status'] == "No":
                result[
                    'notes'] = "Non sono stati trovati strumenti per la gestione automatica delle patch. È necessario implementare un processo di aggiornamento automatico."
            elif result['status'] == "Sì solo applicazioni":
                result[
                    'notes'] = "Sono presenti strumenti per l'aggiornamento, ma non sono configurati per l'aggiornamento automatico. Si consiglia di abilitare gli aggiornamenti automatici."
            elif result['status'] == "Sì automatico con versioni e patch":
                result[
                    'notes'] = "Gli aggiornamenti automatici sono correttamente configurati. Si consiglia di implementare anche una verifica per attacchi pregressi."
            else:
                result[
                    'notes'] = "La gestione delle patch di sicurezza è completamente implementata, inclusa la verifica per attacchi pregressi."

        except Exception as e:
            self.log_error(target, e)
            result['status'] = "ERROR"
            result['details'] = {'error': str(e)}
            result['score'] = 0
        finally:
            duration = time.time() - start_time
            self.log_check_end(target, result['status'], duration)

        return result

    def _check_patch_tools(self, target: Target) -> List[Dict]:
        """
        Verifica la presenza di tool per la gestione delle patch.

        Args:
            target: Target su cui verificare

        Returns:
            Lista di dizionari con informazioni sui tool trovati
        """
        self.logger.debug(f"Checking patch management tools on {target.name}")
        found_tools = []

        for tool in self.PATCH_TOOLS:
            # Controlla se il processo è in esecuzione
            process_running = self.check_process_running(target, tool['process'])

            # Controlla lo stato del servizio
            service_status = {"running": False, "enabled": False}
            if tool['service']:
                service_status = self.check_service_status(target, tool['service'])

            if process_running or service_status.get('running', False):
                self.logger.info(f"Found patch management tool on {target.name}: {tool['name']}")
                found_tools.append({
                    'name': tool['name'],
                    'process_running': process_running,
                    'service_running': service_status.get('running', False),
                    'service_enabled': service_status.get('enabled', False)
                })

        # Per Windows, controlla anche i registri
        if target.os_type.lower() == 'windows':
            # Controlla le impostazioni di Windows Update nel registro
            cmd = 'reg query "HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\WindowsUpdate\\AU" /v NoAutoUpdate'
            result = self.execute_command(target, cmd)

            # NoAutoUpdate=0 significa che gli aggiornamenti automatici sono abilitati
            if result['exit_code'] == 0 and "0x0" in result['stdout']:
                self.logger.info(f"Windows Update automatic updates are enabled on {target.name}")
                found_tools.append({
                    'name': "Windows Update (Registry)",
                    'process_running': True,
                    'service_running': True,
                    'service_enabled': True
                })

        return found_tools

    def _check_auto_update_config(self, target: Target) -> bool:
        """
        Verifica la configurazione dell'aggiornamento automatico.

        Args:
            target: Target su cui verificare

        Returns:
            True se l'aggiornamento automatico è configurato, False altrimenti
        """
        self.logger.debug(f"Checking auto-update configuration on {target.name}")

        # Configurazioni specifiche per sistema operativo
        if target.os_type.lower() in ['linux', 'unix']:
            # Debian/Ubuntu
            apt_config_paths = [
                "/etc/apt/apt.conf.d/20auto-upgrades",
                "/etc/apt/apt.conf.d/50unattended-upgrades"
            ]
            for path in apt_config_paths:
                content = self.read_file_content(target, path)
                if content and re.search(
                        r'APT::Periodic::Update-Package-Lists "1"|Unattended-Upgrade::Automatic-Reboot "true"',
                        content):
                    self.logger.info(f"Found auto-update configuration on {target.name}: {path}")
                    return True

            # Red Hat/CentOS
            yum_config_paths = [
                "/etc/yum/yum-cron.conf",
                "/etc/dnf/automatic.conf"
            ]
            for path in yum_config_paths:
                content = self.read_file_content(target, path)
                if content and re.search(r'apply_updates = yes|upgrade_type = security', content):
                    self.logger.info(f"Found auto-update configuration on {target.name}: {path}")
                    return True

            # SUSE
            zypper_config_paths = [
                "/etc/sysconfig/automatic-update"
            ]
            for path in zypper_config_paths:
                content = self.read_file_content(target, path)
                if content and "AOU_ENABLE_AUTOMATIC_ONLINE_UPDATE=yes" in content:
                    self.logger.info(f"Found auto-update configuration on {target.name}: {path}")
                    return True

        elif target.os_type.lower() == 'windows':
            # Windows Update
            reg_queries = [
                'reg query "HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\WindowsUpdate\\AU" /v AUOptions',
                'reg query "HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate\\Auto Update" /v AUOptions'
            ]

            for query in reg_queries:
                result = self.execute_command(target, query)

                # AUOptions=4 significa "download e installa automaticamente"
                if result['exit_code'] == 0 and "0x4" in result['stdout']:
                    self.logger.info(f"Windows Update is configured for automatic updates on {target.name}")
                    return True

            # WSUS/SCCM
            wsus_queries = [
                'reg query "HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\WindowsUpdate" /v WUServer',
                'reg query "HKLM\\SOFTWARE\\Microsoft\\CCM\\CcmEval" /v LastEvalTime'
            ]

            for query in wsus_queries:
                result = self.execute_command(target, query)

                if result['exit_code'] == 0 and result['stdout'] and "REG_SZ" in result['stdout']:
                    self.logger.info(f"WSUS/SCCM configuration found on {target.name}")
                    return True

        return False

    def _check_recent_updates(self, target: Target) -> List[Dict]:
        """
        Verifica la presenza di aggiornamenti recenti.

        Args:
            target: Target su cui verificare

        Returns:
            Lista di dizionari con informazioni sugli aggiornamenti recenti
        """
        self.logger.debug(f"Checking recent updates on {target.name}")
        recent_updates = []

        if target.os_type.lower() in ['linux', 'unix']:
            # Controlla i log di aggiornamento
            update_logs = [
                "/var/log/apt/history.log",
                "/var/log/dpkg.log",
                "/var/log/yum.log",
                "/var/log/dnf.log",
                "/var/log/zypp/history"
            ]

            for log_path in update_logs:
                # Verifica se il file esiste
                if not self.check_file_exists(target, log_path):
                    continue

                # Controlla le ultime modifiche (ultimi 30 giorni)
                grep_cmd = f"grep -i 'upgrade\\|install\\|update' {log_path} | tail -20"
                result = self.execute_command(target, grep_cmd)

                if result['exit_code'] == 0 and result['stdout']:
                    self.logger.info(f"Found recent updates in log on {target.name}: {log_path}")
                    recent_updates.append({
                        'path': log_path,
                        'content': result['stdout']
                    })

        elif target.os_type.lower() == 'windows':
            # Controlla gli ultimi aggiornamenti di Windows installati
            ps_cmd = 'powershell -Command "Get-HotFix | Sort-Object -Property InstalledOn -Descending | Select-Object -First 10 | Format-Table -Property HotFixID, InstalledOn -AutoSize"'
            result = self.execute_command(target, ps_cmd)

            if result['exit_code'] == 0 and result['stdout'] and "KB" in result['stdout']:
                self.logger.info(f"Found recent Windows updates on {target.name}")
                recent_updates.append({
                    'path': 'Windows Update',
                    'content': result['stdout']
                })

            # Controlla anche i log di Windows Update
            wua_log = 'C:\\Windows\\SoftwareDistribution\\ReportingEvents.log'
            if self.check_file_exists(target, wua_log):
                self.logger.info(f"Found Windows Update log on {target.name}")
                recent_updates.append({
                    'path': wua_log,
                    'content': 'Windows Update log exists'
                })

        return recent_updates

    def _check_attack_scan(self, target: Target) -> bool:
        """
        Verifica se è implementata la scansione per attacchi pregressi dopo l'applicazione delle patch.

        Args:
            target: Target su cui verificare

        Returns:
            True se è implementata la scansione per attacchi pregressi, False altrimenti
        """
        self.logger.debug(f"Checking post-update attack scan on {target.name}")

        # Controlla la presenza di script/configurazioni per la scansione post-patch
        scan_paths = [
            # Linux
            "/etc/cron.d/post-update-scan",
            "/usr/local/bin/post-update-scan.sh",
            "/etc/security/post-patch-scan.conf",
            # Windows
            "C:\\Scripts\\PostUpdateScan.ps1",
            "C:\\ProgramData\\Security\\PostPatchScan.conf"
        ]

        for path in scan_paths:
            if self.check_file_exists(target, path):
                content = self.read_file_content(target, path)
                if content and re.search(r'attack|compromise|breach|ioc|indicator|malware|scan', content,
                                         re.IGNORECASE):
                    self.logger.info(f"Found post-update attack scan configuration on {target.name}: {path}")
                    return True

        # Controlla l'integrazione con strumenti di rilevamento di compromissione
        integration_paths = [
            # Linux
            "/etc/ossec/ossec.conf",
            "/etc/tripwire/twcfg.txt",
            "/etc/aide/aide.conf",
            "/etc/wazuh/ossec.conf",
            # Windows
            "C:\\Program Files\\OSSEC-HIDS\\ossec.conf",
            "C:\\Program Files\\Tripwire\\twcfg.txt",
            "C:\\Program Files\\Wazuh\\ossec.conf"
        ]

        for path in integration_paths:
            if self.check_file_exists(target, path):
                content = self.read_file_content(target, path)
                if content and re.search(r'update|patch|post-update|after-update', content, re.IGNORECASE):
                    self.logger.info(f"Found post-update attack detection integration on {target.name}: {path}")
                    return True

        return False

    def _calculate_custom_score(self, status: str) -> float:
        """
        Calcola un punteggio personalizzato in base allo stato.

        Args:
            status: Stato del controllo

        Returns:
            Punteggio da 0 a 100
        """
        if status == "Sì con verifica attacchi pregressi":
            return 100
        elif status == "Sì automatico con versioni e patch":
            return 80
        elif status == "Sì solo applicazioni":
            return 50
        elif status == "No":
            return 0
        else:
            return 0